<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Vinyl Player</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/gsap.min.js"></script>
    <!-- Optional: jsmediatags for better file metadata (include if needed) -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script> -->
    <style>
        :root {
            --primary-bg: #121212;
            --secondary-bg: #1e1e1e;
            --accent: #e63946;
            --text: #f1faee;
            --text-secondary: #a8a8a8;
            --vinyl: #333;
            --vinyl-center: #111;
            --vinyl-label-bg: #555;
            --player-shadow: rgba(0, 0, 0, 0.5);
            --retro-border: 3px solid #444;
            --button-shadow: 4px 4px 0px rgba(0, 0, 0, 0.3);
            --alert-bg: #ff4444;
            --alert-border: #ff0000;
            --alert-text: white;
            --canvas-bg: rgba(0, 0, 0, 0.2);
            --eq-bg: #2a2a2a;
            --eq-slider-thumb: var(--accent);
            --eq-slider-track: #555;
        }

        /* --- THEMES --- */
        .theme-mkbhd { /* Default */ }
        .theme-spotify { --primary-bg: #191414; --secondary-bg: #212121; --accent: #1db954; --font-family:'sf pro display';  --text: #ffffff; --vinyl-label-bg: #444; --eq-slider-thumb: #1db954; }
        .theme-youtube { --primary-bg: #0f0f0f; --secondary-bg: #222222; --accent: #ff0000; --text: #f1f1f1; --vinyl-center: #000; --vinyl-label-bg: #444; --eq-slider-thumb: #ff0000; }
        .theme-oldmoney { --primary-bg: #f5f5dc; --secondary-bg: #e8e8cc; --accent: #c0b283; --text: #373737; --text-secondary: #6b5a3b; --vinyl: #a98f5a; --vinyl-center: #f5f5dc; --vinyl-label-bg: #e8e8cc; --player-shadow: rgba(192, 178, 131, 0.3); --retro-border: 3px solid #a98f5a; --button-shadow: 4px 4px 0px rgba(107, 90, 59, 0.3); --alert-bg: #c0b283; --alert-border: #a98f5a; --alert-text: #373737; --eq-bg: #dcd0b0; --eq-slider-thumb: #a98f5a; --eq-slider-track: #bcae8d; --canvas-bg: rgba(55, 55, 55, 0.1); }
        .theme-vintage { --primary-bg: #3a3226; --secondary-bg: #4a4238; --accent: #8b5a2b; --text: #e2d5c3; --text-secondary: #ab9b84; --vinyl: #5d4b36; --vinyl-center: #3a3226; --vinyl-label-bg: #4a4238; --player-shadow: rgba(139, 90, 43, 0.3); --retro-border: 3px solid #6b4a23; --button-shadow: 4px 4px 0px rgba(58, 50, 38, 0.4); --alert-bg: #8b5a2b; --alert-border: #6b4a23; --alert-text: #e2d5c3; --eq-bg: #5a5248; --eq-slider-thumb: #8b5a2b; --eq-slider-track: #7b6a5b; --canvas-bg: rgba(226, 213, 195, 0.05); }
        .theme-notion { --primary-bg: #ffffff; --secondary-bg: #f7f7f7; --accent: #ff6633; --text: #333333; --text-secondary: #777777; --vinyl: #e0e0e0; --vinyl-center: #f0f0f0; --vinyl-label-bg: #ffffff; --player-shadow: rgba(0, 0, 0, 0.1); --retro-border: 2px solid #dddddd; --button-shadow: 3px 3px 0px rgba(0, 0, 0, 0.1); --alert-bg: #ff6633; --alert-border: #e04e1a; --alert-text: white; --eq-bg: #eeeeee; --eq-slider-thumb: #ff6633; --eq-slider-track: #cccccc; --canvas-bg: rgba(0, 0, 0, 0.03); }
        .theme-lofi { --primary-bg: #2a2d3a; --secondary-bg: #3c4051; --accent: #ffb6c1; /* Light Pink */ --text: #e0e0e0; --text-secondary: #a0a5b8; --vinyl: #4f5469; --vinyl-center: #353947; --vinyl-label-bg: #3c4051; --player-shadow: rgba(0, 0, 0, 0.3); --retro-border: 3px solid #5a5f73; --button-shadow: 4px 4px 0px rgba(42, 45, 58, 0.4); --alert-bg: #ffb6c1; --alert-border: #f8a0ac; --alert-text: #2a2d3a; --eq-bg: #4f5469; --eq-slider-thumb: #ffb6c1; --eq-slider-track: #72788d; --canvas-bg: rgba(255, 182, 193, 0.05); }


        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'fira code', Tahoma, Geneva, Verdana, sans-serif; }

        body { background-color: var(--primary-bg); color: var(--text); transition: background-color 0.5s ease, color 0.5s ease; min-height: 100vh; overflow-x: hidden; display: flex; justify-content: center; }

        .app-container { display: flex; flex-direction: column; height: 100vh; width: 100%; max-width: 1400px; /* Wider max width */ margin: 0 auto; position: relative; transition: padding-bottom 0.5s ease; /* For minimal mode */ }

        .player-container { display: grid; grid-template-columns: 300px 1fr 300px; /* Fixed sidebars, flexible center */ gap: 25px; padding: 20px; flex-grow: 1; overflow: hidden; transition: grid-template-columns 0.5s ease, gap 0.5s ease; }

        .vinyl-section { grid-column: 2; display: flex; flex-direction: column; /* Stack vinyl and visualizer */ align-items: center; justify-content: center; position: relative; perspective: 1000px; min-height: 420px; transition: transform 0.5s ease; }

        .vinyl-player { /* styles mostly unchanged... */ width: 400px; height: 400px; border-radius: 50%; /* ... other vinyl styles */ position: relative; z-index: 2; transition: width 0.5s ease, height 0.5s ease; display: flex; justify-content: center; align-items: center; border: 8px solid var(--secondary-bg); /* Existing styles */ background: radial-gradient(circle at 50% 50%, var(--vinyl-center) 18%, var(--vinyl) 18.5%, var(--vinyl) 68%, var(--vinyl-center) 70%, #000 100%); box-shadow: 0 15px 40px var(--player-shadow), 0 0 20px rgba(0, 0, 0, 0.2) inset; }
        .vinyl-player::before { content: ''; position: absolute; width: 100%; height: 100%; border-radius: 50%; background: linear-gradient(45deg, transparent 40%, rgba(255, 255, 255, 0.08) 50%, transparent 60%); top: 0; left: 0; pointer-events: none; }
        .vinyl-player::after { content: ''; position: absolute; top: 18.5%; left: 18.5%; right: 18.5%; bottom: 18.5%; border-radius: 50%; background-image: repeating-radial-gradient(circle at 50% 50%, rgba(0,0,0,0.1) 0px, rgba(0,0,0,0.1) 1px, transparent 1px, transparent 3px); pointer-events: none; opacity: 0.5; }
        .vinyl-label { /* styles unchanged... */ width: 140px; height: 140px; border-radius: 50%; background: var(--vinyl-label-bg); box-shadow: 0 0 15px rgba(0, 0, 0, 0.3) inset; border: 2px solid rgba(255, 255, 255, 0.1); display: flex; justify-content: center; align-items: center; z-index: 2; position: relative; transition: background-color 0.5s ease; }
        .vinyl-hole { /* styles unchanged... */ width: 25px; height: 25px; border-radius: 50%; background-color: var(--primary-bg); border: 3px solid var(--text-secondary); z-index: 3; transition: background-color 0.5s ease, border-color 0.5s ease; }
        .vinyl-arm { /* styles unchanged... */ position: absolute; width: 180px; height: 10px; background-color: var(--text-secondary); top: calc(50% - 180px - 20px); /* Adjusted for visualizer */ left: calc(50% + 120px); transform-origin: 10px 5px; transform: rotate(-45deg); z-index: 5; border-radius: 5px; box-shadow: 2px 2px 5px rgba(0,0,0,0.3); transition: transform 0.5s ease, background-color 0.5s ease; }
        .vinyl-arm::after { /* Stylus head */ content: ''; position: absolute; width: 20px; height: 20px; background-color: var(--text-secondary); border-radius: 3px; right: -5px; top: 50%; transform: translateY(-50%) rotate(45deg); box-shadow: 1px 1px 3px rgba(0,0,0,0.4); }
        .vinyl-arm::before { /* Base */ content: ''; position: absolute; width: 25px; height: 25px; background-color: var(--text-secondary); border-radius: 50%; left: -5px; top: 50%; transform: translateY(-50%); box-shadow: 1px 1px 3px rgba(0,0,0,0.4); }
        .vinyl-arm.playing { transform: rotate(-15deg); }
        .spinning { animation: spin 3s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

        /* --- VISUALIZER --- */
        .visualizer-container {
            width: 100%;
            max-width: 450px; /* Slightly wider than vinyl */
            height: 80px; /* Height for visualizer bars */
            margin-top: 20px; /* Space below vinyl */
            position: relative;
            z-index: 1;
            background: var(--canvas-bg);
            border-radius: 5px;
            overflow: hidden;
            transition: height 0.5s ease, opacity 0.5s ease;
        }
       

        /* --- SIDEBARS --- */
        .controls-section, .song-history-section {
            background: var(--secondary-bg); border: var(--retro-border); box-shadow: var(--button-shadow); border-radius: 15px; padding: 25px; margin: 0; /* Grid gap handles spacing */ transform-style: preserve-3d; transition: background-color 0.5s ease, border-color 0.5s ease, transform 0.5s ease, opacity 0.5s ease; display: flex; flex-direction: column; overflow: hidden; /* Important */
            grid-row: 1; /* Span full height implicitly */
        }
        .controls-section { grid-column: 1; }
        .song-history-section { grid-column: 3; background: var(--primary-bg); border-color: var(--accent); }

        .song-info { /* styles mostly unchanged */ text-align: center; margin-bottom: 20px; min-height: 50px; }
        .song-title { font-size: 22px; font-weight: 600; margin-bottom: 5px; line-height: 1.2; }
        .song-artist { font-size: 15px; color: var(--text-secondary); transition: color 0.5s ease; }

        .progress-container { /* styles mostly unchanged */ background: #333; border: var(--retro-border); box-shadow: inset 2px 2px 4px rgba(0, 0, 0, 0.2); height: 10px; border-radius: 5px; cursor: pointer; margin-bottom: 5px; overflow: hidden; transition: border-color 0.5s ease, transform 0.5s ease; position: relative; z-index: 10; /* Above vinyl in minimal */ }
        .progress-bar { background: linear-gradient(90deg, var(--accent), color-mix(in srgb, var(--accent) 80%, #fff 20%)); box-shadow: inset 1px 1px 3px rgba(255, 255, 255, 0.15); height: 100%; width: 0%; border-radius: 3px; transition: width 0.1s linear, background 0.5s ease; }
        .time-info { display: flex; justify-content: space-between; font-size: 12px; color: var(--text-secondary); margin-bottom: 20px; transition: color 0.5s ease; }

        .controls { display: flex; justify-content: center; align-items: center; gap: 20px; margin-bottom: 20px; }
        .control-btn { /* styles mostly unchanged */ background: linear-gradient(145deg, #666, #444); border: var(--retro-border); box-shadow: var(--button-shadow); color: #fff; font-size: 18px; width: 50px; height: 50px; border-radius: 50%; display: flex; justify-content: center; align-items: center; cursor: pointer; position: relative; transition: background 0.2s ease, transform 0.15s ease, box-shadow 0.15s ease, border-color 0.5s ease; }
        .control-btn:hover { transform: translateY(-2px); box-shadow: 6px 6px 0px rgba(0, 0, 0, 0.3); }
        .control-btn:active { transform: translate(2px, 2px); box-shadow: 2px 2px 0px rgba(0, 0, 0, 0.3); }
        .control-btn.play-pause { /* styles mostly unchanged */ background: linear-gradient(145deg, var(--accent), color-mix(in srgb, var(--accent) 70%, #000 30%)); width: 70px; height: 70px; font-size: 22px; color: var(--text); transition: background 0.5s ease, color 0.5s ease, transform 0.15s ease, box-shadow 0.15s ease; }
        .control-btn.play-pause:hover { box-shadow: 6px 6px 0px rgba(0, 0, 0, 0.3), 0 0 15px color-mix(in srgb, var(--accent) 50%, transparent); }
        .control-btn.play-pause:active { transform: translate(2px, 2px); box-shadow: 2px 2px 0px rgba(0, 0, 0, 0.3); }

        .volume-control { display: flex; align-items: center; gap: 10px; margin-top: 15px; margin-bottom: 15px; }
        .volume-control i { color: var(--text-secondary); transition: color 0.5s ease; }
        .volume-slider { flex: 1; appearance: none; -webkit-appearance: none; height: 6px; background-color: var(--primary-bg); border-radius: 3px; cursor: pointer; border: 1px solid var(--text-secondary); transition: background-color 0.5s ease, border-color 0.5s ease; }
        .volume-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 14px; height: 14px; border-radius: 50%; background-color: var(--accent); border: 1px solid var(--primary-bg); cursor: pointer; transition: background-color 0.5s ease; }
        .volume-slider::-moz-range-thumb { width: 14px; height: 14px; border-radius: 50%; background-color: var(--accent); border: 1px solid var(--primary-bg); cursor: pointer; transition: background-color 0.5s ease; }

        /* --- AUDIO EFFECTS CONTROLS --- */
        .effects-section {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid var(--text-secondary);
        }
        .effects-title { font-size: 16px; margin-bottom: 15px; color: var(--accent); }
        .effect-control { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
        .effect-control label { font-size: 13px; width: 50px; color: var(--text-secondary); }
        .effect-control input[type="range"] { flex: 1; height: 4px; /* thinner */ background: var(--eq-slider-track); border-radius: 2px; cursor: pointer; appearance: none; -webkit-appearance: none; border: none; transition: background-color 0.5s ease; }
        .effect-control input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 12px; height: 12px; border-radius: 50%; background-color: var(--eq-slider-thumb); cursor: pointer; transition: background-color 0.5s ease; }
        .effect-control input[type="range"]::-moz-range-thumb { width: 12px; height: 12px; border-radius: 50%; background-color: var(--eq-slider-thumb); cursor: pointer; border: none; transition: background-color 0.5s ease; }
        .effect-control .value-display { font-size: 12px; min-width: 30px; text-align: right; color: var(--text-secondary); }
        .effect-control input[type="checkbox"] { margin-left: auto; accent-color: var(--accent); } /* Reverb Toggle */


        /* --- SONG HISTORY & ADDING --- */
         .add-song-container {
            margin-top: auto; /* Push to bottom */
             padding-top: 15px;
             border-top: 1px solid var(--text-secondary);
         }
         .add-song-btn-trigger { /* Style the button that opens file input */
             display: block;
             width: 100%;
             padding: 10px 20px;
             border-radius: 25px;
             border: none;
             background-color: var(--accent);
             color: var(--text);
             cursor: pointer;
             transition: transform 0.2s ease, background-color 0.5s ease, color 0.5s ease;
             text-align: center;
             font-weight: 500;
             box-shadow: var(--button-shadow);
         }
         .add-song-btn-trigger:hover {
             transform: scale(1.03);
             filter: brightness(1.1);
         }
         .add-song-btn-trigger i { margin-right: 8px; }
         .add-song-btn-trigger .fa-spinner {
             font-size: 18px; /* Bigger Spinner */
             /* Centering is handled by flex on button */
         }

        #add-song-input-hidden { display: none; } /* Hide actual file input */


        .song-history { flex-grow: 1; overflow-y: auto; padding-right: 5px; /* Space for scrollbar */ margin-bottom: 15px; }
        .song-history::-webkit-scrollbar { width: 6px; }
        .song-history::-webkit-scrollbar-track { background: var(--primary-bg); border-radius: 3px; }
        .song-history::-webkit-scrollbar-thumb { background-color: var(--text-secondary); border-radius: 3px; border: 1px solid var(--primary-bg); }
        .song-history { scrollbar-width: thin; scrollbar-color: var(--text-secondary) var(--primary-bg); }

        .history-title { /* styles mostly unchanged */ font-size: 18px; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--text-secondary); color: var(--accent); position: sticky; top: -25px; background: var(--primary-bg); z-index: 10; transition: color 0.5s ease, border-color 0.5s ease, background-color 0.5s ease; padding-top: 15px; margin-left: -25px; margin-right: -25px; padding-left: 25px; }

        .history-list { list-style: none; }
        .history-item { /* styles mostly unchanged */ padding: 10px; border-radius: 8px; margin-bottom: 8px; cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease; display: flex; justify-content: space-between; align-items: center; border: 1px solid transparent; }
        .history-item:hover { background-color: rgba(255, 255, 255, 0.05); transform: translateX(3px); border-color: var(--text-secondary); }
        .history-item.active { background-color: var(--accent); color: var(--text); border-color: var(--accent); transform: translateX(0); }
        .history-item.active:hover { background-color: color-mix(in srgb, var(--accent) 90%, #000 10%); }
        .history-item-info { flex: 1; margin-right: 10px; overflow: hidden; }
        .history-item-title { font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .history-item-artist { font-size: 12px; color: var(--text-secondary); transition: color 0.5s ease; }
        .history-item.active .history-item-artist { color: var(--text); }
        .history-item-duration { font-size: 12px; color: var(--text-secondary); white-space: nowrap; transition: color 0.5s ease; }
        .history-item.active .history-item-duration { color: var(--text); }
        .remove-btn { background: none; border: none; color: var(--text-secondary); cursor: pointer; margin-left: 10px; padding: 5px; font-size: 14px; transition: color 0.2s ease, transform 0.1s ease; }
        .remove-btn:hover { color: var(--accent); transform: scale(1.2); }
        .history-item.active .remove-btn { color: var(--text); }
        .history-item.active .remove-btn:hover { color: color-mix(in srgb, var(--text) 80%, #000 20%); }


        /* --- BOTTOM NAV & MINIMAL TOGGLE --- */
        .bottom-nav { display: flex; justify-content: center; align-items: center; /* Vertically align */ padding: 10px; background-color: var(--secondary-bg); border-top: var(--retro-border); border-color: rgba(255, 255, 255, 0.1); transition: background-color 0.5s ease, border-color 0.5s ease, transform 0.5s ease, opacity 0.5s ease; flex-shrink: 0; position: relative; /* For absolute positioning toggle */ }
        .nav-btn { background: none; border: var(--retro-border); border-color: transparent; color: var(--text-secondary); font-size: 16px; cursor: pointer; padding: 8px 18px; border-radius: 25px; transition: all 0.2s ease; margin: 0 5px; box-shadow: var(--button-shadow); background-color: var(--primary-bg); transition: background-color 0.2s ease, color 0.2s ease, transform 0.15s ease, box-shadow 0.15s ease; }
        .nav-btn i { margin-right: 8px; }
        .nav-btn:hover { background-color: color-mix(in srgb, var(--accent) 20%, var(--primary-bg) 80%); color: var(--accent); transform: translateY(-2px); box-shadow: 4px 6px 0px rgba(0, 0, 0, 0.3); }
        .nav-btn.active, .nav-btn:active { background-color: var(--accent); color: var(--text); border-color: color-mix(in srgb, var(--accent) 80%, #000 20%); transform: translate(2px, 2px); box-shadow: 2px 2px 0px rgba(0, 0, 0, 0.3); }

        #minimal-toggle-btn {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 18px; /* Icon size */
             width: 40px; height: 40px; /* Make it square */
             padding: 0; /* Remove padding */
             display: flex; align-items: center; justify-content: center;
        }


        /* --- MODALS (Themes, Profile) --- */
        /* Styles mostly unchanged, ensure z-index is high */
        .modal { z-index: 1000; /* ... other modal styles */ position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: flex; align-items: center; justify-content: center; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; }
        .modal.active { opacity: 1; pointer-events: all; }
        .modal-content { background-color: var(--secondary-bg); padding: 30px; border-radius: 15px; border: var(--retro-border); border-color: var(--accent); max-width: 500px; width: 90%; max-height: 85vh; overflow-y: auto; transform: scale(0.95) translateY(20px); transition: transform 0.3s ease, opacity 0.3s ease, background-color 0.5s ease, border-color 0.5s ease; opacity: 0; box-shadow: 0 10px 30px rgba(0,0,0,0.4); }
        .modal.active .modal-content { transform: scale(1) translateY(0); opacity: 1; }
        .modal-title { font-size: 24px; margin-bottom: 25px; color: var(--accent); text-align: center; transition: color 0.5s ease; }
        .theme-options { display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); /* Adjust size */ gap: 15px; }
        .theme-option { padding: 15px 10px; /* Adjust padding */ border-radius: 10px; cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease; text-align: center; background-color: var(--primary-bg); border: 3px solid transparent; box-shadow: var(--button-shadow); transition: background-color 0.5s ease, box-shadow 0.2s ease, transform 0.2s ease; }
        .theme-option:hover { transform: translateY(-3px) scale(1.03); box-shadow: 6px 8px 0px rgba(0, 0, 0, 0.3); }
        .theme-option.mkbhd { border-color: #e63946; } .theme-option.spotify { border-color: #1db954; } .theme-option.youtube { border-color: #ff0000; } .theme-option.oldmoney { border-color: #c0b283; } .theme-option.vintage { border-color: #8b5a2b; }
        .theme-option.notion { border-color: #ff6633; } .theme-option.lofi { border-color: #ffb6c1; }
        .theme-option i { font-size: 25px; margin-bottom: 8px; }
        .theme-name { font-weight: 600; margin-top: 8px; font-size: 14px; }
        .profile-form { display: flex; flex-direction: column; gap: 20px; } .form-group { display: flex; flex-direction: column; gap: 8px; } .form-label { font-size: 14px; font-weight: 500; color: var(--text-secondary); transition: color 0.5s ease; }
        .form-input { padding: 12px 15px; border-radius: 5px; border: 1px solid var(--text-secondary); background-color: var(--primary-bg); color: var(--text); outline: none; font-size: 1rem; transition: background-color 0.5s ease, color 0.5s ease, border-color 0.2s ease, box-shadow 0.2s ease; }
        .form-input:focus { border-color: var(--accent); box-shadow: 0 0 8px color-mix(in srgb, var(--accent) 40%, transparent); }
        .form-input[type="color"] { padding: 5px; height: 45px; }
        .save-btn { padding: 12px; border-radius: 5px; border: var(--retro-border); border-color: color-mix(in srgb, var(--accent) 80%, #000 20%); background-color: var(--accent); color: var(--text); cursor: pointer; transition: all 0.15s ease; margin-top: 10px; font-size: 1rem; font-weight: 600; box-shadow: var(--button-shadow); transition: background-color 0.5s ease, color 0.5s ease, transform 0.15s ease, box-shadow 0.15s ease, border-color 0.5s ease; }
        .save-btn:hover { transform: translateY(-2px); box-shadow: 6px 6px 0px rgba(0, 0, 0, 0.3); filter: brightness(1.1); }
        .save-btn:active { transform: translate(2px, 2px); box-shadow: 2px 2px 0px rgba(0, 0, 0, 0.3); filter: brightness(0.9); }


        /* --- MINIMAL MODE --- */
        .app-container.minimal-mode .player-container {
            grid-template-columns: 1fr; /* Single column */
            gap: 0;
            padding: 10px;
        }
        .app-container.minimal-mode .vinyl-section {
            /* Center it, maybe scale down slightly? */
             justify-content: center;
             min-height: unset;
             margin-bottom: 10px; /* Space before progress bar */
        }
        .app-container.minimal-mode .vinyl-player {
            width: 300px; /* Or adjust as needed */
            height: 300px;
        }
         /* Keep arm relative to smaller player */
        .app-container.minimal-mode .vinyl-arm {
             width: 140px; height: 8px;
             top: calc(50% - 140px - 10px); /* Adjust for smaller size */
             left: calc(50% + 90px);
         }
        .app-container.minimal-mode .visualizer-container {
            max-width: 350px;
            height: 60px;
             margin-top: 10px;
         }
        .app-container.minimal-mode .progress-container {
            width: 90%;
            max-width: 400px;
            margin: 0 auto; /* Center the progress bar */
        }
        /* Hide sidebars and bottom nav */
        .app-container.minimal-mode .controls-section,
        .app-container.minimal-mode .song-history-section,
        .app-container.minimal-mode .bottom-nav {
             /* These will be animated out by GSAP */
             opacity: 0;
             pointer-events: none;
        }

        /* --- RETRO ALERT --- */
        /* Style unchanged */
        #retro-alert-container { position: fixed; top: 0; left: 50%; transform: translateX(-50%); z-index: 1001; width: 90%; max-width: 500px; pointer-events: none; }
        .retro-alert { pointer-events: all; background: var(--alert-bg); color: var(--alert-text); padding: 12px 25px; border: 3px solid var(--alert-border); box-shadow: var(--button-shadow); font-family: 'Courier New', monospace; font-weight: bold; transition: top 0.5s ease-in-out, opacity 0.5s ease; border-radius: 8px; text-align: center; margin-top: 10px; position: relative; top: -150px; opacity: 0;}
        .retro-alert.show { top: 10px; opacity: 1; }


        /* --- RESPONSIVENESS --- */
        @media (max-width: 1000px) {
            .player-container { grid-template-columns: 250px 1fr 250px; /* Shrink sidebars */ gap: 15px; padding: 15px; }
             .vinyl-player { width: 300px; height: 300px; }
             .vinyl-arm { width: 140px; height: 8px; top: calc(50% - 140px - 15px); left: calc(50% + 90px); }
             .visualizer-container { max-width: 350px; height: 70px;}
        }

        @media (max-width: 768px) {
            .player-container { grid-template-columns: 1fr; /* Stack */ height: auto; overflow-y: auto; }
            .controls-section { grid-row: 2; min-height: 300px; }
            .song-history-section { grid-row: 3; min-height: 250px; }
            .vinyl-section { grid-row: 1; min-height: unset; margin-bottom: 10px; }
             .vinyl-player { width: 250px; height: 250px; }
             .vinyl-arm { width: 120px; height: 7px; top: calc(50% - 120px - 10px); left: calc(50% + 75px); }
             .visualizer-container { max-width: 300px; height: 60px;}
            .controls-section, .song-history-section { padding: 20px; }
            .history-title { top: -20px; margin-left: -20px; margin-right: -20px; padding-left: 20px; }
            #minimal-toggle-btn { display: none; } /* Hide minimal toggle on small screens? Or adjust layout */

            /* Minimal mode adjustments for stacked layout */
             .app-container.minimal-mode .player-container { padding: 10px; }
             .app-container.minimal-mode .vinyl-player { width: 220px; height: 220px; }
             .app-container.minimal-mode .vinyl-arm { width: 110px; height: 6px; top: calc(50% - 110px - 5px); left: calc(50% + 65px); }
             .app-container.minimal-mode .visualizer-container { max-width: 250px; height: 50px; }
             .app-container.minimal-mode .progress-container { max-width: 300px; }

        }
         @media (max-width: 480px) {
             .vinyl-player { width: 200px; height: 200px; border-width: 6px;}
             .vinyl-label { width: 80px; height: 80px;}
             .vinyl-hole { width: 15px; height: 15px; border-width: 2px;}
             .vinyl-arm { width: 100px; height: 6px; top: calc(50% - 100px - 5px); left: calc(50% + 60px); }
             .visualizer-container { max-width: 220px; height: 50px;}
             .song-title { font-size: 18px; } .song-artist { font-size: 14px; }
             .controls { gap: 15px; } .control-btn { width: 45px; height: 45px; font-size: 16px; }
             .control-btn.play-pause { width: 60px; height: 60px; font-size: 20px; }
             .bottom-nav { padding: 8px; } .nav-btn { padding: 6px 12px; font-size: 14px; margin: 0 3px;}
             .modal-content { padding: 20px;} .modal-title { font-size: 20px;}
         }

    </style>
</head>

<body>
    <!-- Alert Container -->
    <div id="retro-alert-container"></div>

    <!-- Hidden File Input -->
    <input type="file" id="add-song-input-hidden" accept="audio/*" multiple style="display: none;">

    <div class="app-container">
        <div class="player-container">
            <!-- Controls Section (Left Sidebar) -->
            <div class="controls-section">
                <div class="song-info">
                    <h2 class="song-title">No song selected</h2>
                    <p class="song-artist">Upload audio files</p>
                </div>

                 <!-- Time Info moved above controls -->
                 <div class="time-info">
                    <span class="current-time">0:00</span>
                    <span class="duration">0:00</span>
                 </div>
                <!-- Progress Bar moved below controls in HTML structure, but positioned visually later if needed -->

                <div class="controls">
                    <button type="button" class="control-btn prev-btn" aria-label="Previous Song">
                        <i class="fas fa-step-backward"></i>
                    </button>
                    <button type="button" class="control-btn play-pause" aria-label="Play">
                        <i class="fas fa-play"></i>
                    </button>
                    <button type="button" class="control-btn next-btn" aria-label="Next Song">
                        <i class="fas fa-step-forward"></i>
                    </button>
                </div>

                <div class="volume-control">
                    <i class="fas fa-volume-down" aria-hidden="true"></i>
                    <input type="range" class="volume-slider" min="0" max="1" step="0.01" value="0.7" aria-label="Volume">
                    <i class="fas fa-volume-up" aria-hidden="true"></i>
                </div>

                <!-- Audio Effects Section -->
                <div class="effects-section">
                    <h4 class="effects-title">Audio Effects</h4>
                    <div class="effect-control">
                        <label for="eq-low">Low</label>
                        <input type="range" id="eq-low" class="eq-slider" min="-15" max="15" step="1" value="0" aria-label="Low EQ">
                        <span class="value-display" id="eq-low-val">0 dB</span>
                    </div>
                    <div class="effect-control">
                        <label for="eq-mid">Mid</label>
                        <input type="range" id="eq-mid" class="eq-slider" min="-15" max="15" step="1" value="0" aria-label="Mid EQ">
                         <span class="value-display" id="eq-mid-val">0 dB</span>
                    </div>
                    <div class="effect-control">
                        <label for="eq-high">High</label>
                        <input type="range" id="eq-high" class="eq-slider" min="-15" max="15" step="1" value="0" aria-label="High EQ">
                         <span class="value-display" id="eq-high-val">0 dB</span>
                    </div>
                     <div class="effect-control">
                         <label for="reverb-toggle">Reverb</label>
                         <input type="checkbox" id="reverb-toggle" aria-label="Toggle Reverb">
                     </div>
                </div>
            </div>

            <!-- Vinyl Section (Center) -->
            <div class="vinyl-section">
                <div class="vinyl-player">
                    <div class="vinyl-label">
                        <div class="vinyl-hole"></div>
                    </div>
                </div>
                <div class="vinyl-arm"></div>
                 <!-- Visualizer Canvas -->
                 <div class="visualizer-container">
                    <canvas id="visualizer-canvas"></canvas>
                 </div>
                 <!-- Progress Bar: Positioned here for minimal mode -->
                 <div class="progress-container" aria-label="Song progress">
                     <div class="progress-bar" style="width: 0%;"></div>
                 </div>
            </div>

            <!-- Song History Section (Right Sidebar) -->
            <div class="song-history-section">
                <h3 class="history-title">Playlist</h3>
                <div class="song-history">
                    <ul class="history-list">
                         <!-- JS will populate this -->
                         <!-- Add message if list is empty -->
                        <li class="history-empty-message" style="text-align: center; color: var(--text-secondary); padding: 20px; display: none;">Upload songs using the button below.</li>
                    </ul>
                </div>
                <div class="add-song-container">
                    <button type="button" class="add-song-btn-trigger" id="add-song-btn-trigger">
                        <i class="fas fa-plus"></i> Add Audio Files
                    </button>
                </div>
            </div>
        </div>

        <!-- Bottom Navigation -->
        <nav class="bottom-nav">
            <button type="button" class="nav-btn" id="themes-btn" aria-label="Open theme selection">
                <i class="fas fa-palette"></i> Themes
            </button>
            <button type="button" class="nav-btn" id="profile-btn" aria-label="Open profile settings">
                <i class="fas fa-user"></i> Profile
            </button>
            <!-- Minimal Mode Toggle Button -->
            <button type="button" class="nav-btn" id="minimal-toggle-btn" aria-label="Toggle Minimal Mode">
                 <i class="fas fa-compress-alt"></i> <!-- Initial Icon -->
            </button>
        </nav>
    </div>

    <!-- Themes Modal -->
    <div class="modal" id="themes-modal" role="dialog" aria-modal="true" aria-labelledby="themes-modal-title">
        <div class="modal-content">
            <h2 class="modal-title" id="themes-modal-title">Select Theme</h2>
            <div class="theme-options">
                <div class="theme-option mkbhd" data-theme="mkbhd"><i class="fas fa-headphones" style="color: #e63946;"></i><div class="theme-name">MKBHD</div></div>
                <div class="theme-option spotify" data-theme="spotify"><i class="fab fa-spotify" style="color: #1db954;"></i><div class="theme-name">Spotify</div></div>
                <div class="theme-option youtube" data-theme="youtube"><i class="fab fa-youtube" style="color: #ff0000;"></i><div class="theme-name">YouTube</div></div>
                <div class="theme-option oldmoney" data-theme="oldmoney"><i class="fas fa-coins" style="color: #c0b283;"></i><div class="theme-name">Old Money</div></div>
                <div class="theme-option vintage" data-theme="vintage"><i class="fas fa-record-vinyl" style="color: #8b5a2b;"></i><div class="theme-name">Vintage</div></div>
                <div class="theme-option notion" data-theme="notion"><i class="fas fa-feather-alt" style="color: #ff6633;"></i><div class="theme-name">Notion</div></div>
                <div class="theme-option lofi" data-theme="lofi"><i class="fas fa-headphones-alt" style="color: #ffb6c1;"></i><div class="theme-name">Lo-fi</div></div>
            </div>
            <button type="button" class="nav-btn modal-close-btn" style="margin-top: 20px; width: 100%;">Close</button>
        </div>
    </div>

    <!-- Profile Modal -->
    <div class="modal" id="profile-modal" role="dialog" aria-modal="true" aria-labelledby="profile-modal-title">
         <div class="modal-content">
            <h2 class="modal-title" id="profile-modal-title">Profile Settings</h2>
            <form class="profile-form" id="profile-form">
                 <!-- Profile form content unchanged -->
                <div class="form-group"> <label class="form-label" for="username-input">Username</label> <input type="text" id="username-input" class="form-input" placeholder="Enter your username"> </div>
                <div class="form-group"> <label class="form-label" for="genre-select">Favorite Genre</label> <select id="genre-select" class="form-input"> <option>Rock</option> <option>Pop</option> <option>Hip Hop</option> <option>Electronic</option> <option>Jazz</option> <option>Classical</option> <option>Other</option> </select> </div>
                <div class="form-group"> <label class="form-label" for="color-input">Profile Color (Accent)</label> <input type="color" id="color-input" class="form-input" value="#e63946" aria-label="Select profile accent color"> </div>
                 <button type="button" class="save-btn" id="save-profile-btn">Save Settings</button>
            </form>
             <button type="button" class="nav-btn modal-close-btn" style="margin-top: 20px; width: 100%;">Close</button>
        </div>
    </div>


    <script>
        class MusicPlayer {
            constructor() {
                // State
                this.songs = []; // Array of { title: string, artist: string, duration: string, blobUrl: string | null, fileHandle?: FileSystemFileHandle } - blobUrl is temporary!
                this.currentSongIndex = -1;
                this.isPlaying = false;
                this.isMinimalMode = false;
                this.alertTimeout = null;

                // Audio API Core
                this.audioContext = null; // Created on first user interaction
                this.audioElement = new Audio(); // Primary playback element
                this.sourceNode = null; // Connects audioElement to context
                this.analyserNode = null;
                this.gainNode = null; // Master gain before destination

                // Effects Nodes
                this.eqNodes = { low: null, mid: null, high: null };
                this.reverbNode = null; // ConvolverNode
                this.reverbGain = null; // To control reverb mix
                this.reverbBuffer = null; // Loaded impulse response
                this.isReverbEnabled = false;

                // Sound Effects
                this.stylusSound = new Audio('/path/to/your/stylus-drop.wav'); // Replace with actual path
                this.scratchSound = new Audio('/path/to/your/record-scratch.wav'); // Replace with actual path
                this.stylusSound.volume = 0.3;
                this.scratchSound.volume = 0.4;

                // Visualizer
                this.canvas = document.getElementById('visualizer-canvas');
                this.canvasCtx = this.canvas.getContext('2d');
                this.animationFrameId = null;
                this.visualizerDataArray = null;

                this.initElements();
                this.initEventListeners();
                this.loadStateFromLocalStorage(); // Load saved state (theme, volume, playlist metadata, effects)
                this.initGSAPAnimations();
                 this.updateEmptyMessage();
                 // Apply loaded theme immediately
                 this.applyTheme(localStorage.getItem('vinylPlayerTheme') || 'mkbhd');

                console.log("Vinyl Player Initialized");
                 this.showRetroAlert("Welcome! Upload audio files to begin.", 4000);
            }

            // --- INITIALIZATION ---

            initElements() {
                // Core UI
                this.appContainer = document.querySelector('.app-container');
                this.playerContainer = document.querySelector('.player-container');
                this.vinylSection = document.querySelector('.vinyl-section');
                this.vinylPlayer = document.querySelector('.vinyl-player');
                this.vinylArm = document.querySelector('.vinyl-arm');
                this.songTitle = document.querySelector('.song-title');
                this.songArtist = document.querySelector('.song-artist');
                this.progressBar = document.querySelector('.progress-bar');
                this.progressContainer = this.vinylSection.querySelector('.progress-container'); // Moved under vinyl visually
                this.currentTimeEl = document.querySelector('.current-time');
                this.durationEl = document.querySelector('.duration');
                this.playPauseBtn = document.querySelector('.play-pause');
                this.prevBtn = document.querySelector('.prev-btn');
                this.nextBtn = document.querySelector('.next-btn');
                this.volumeSlider = document.querySelector('.volume-slider');
                this.alertContainer = document.getElementById('retro-alert-container');
                this.minimalToggleBtn = document.getElementById('minimal-toggle-btn');

                 // Playlist/History
                 this.historyList = document.querySelector('.history-list');
                 this.addSongTriggerBtn = document.getElementById('add-song-btn-trigger');
                 this.hiddenFileInput = document.getElementById('add-song-input-hidden');
                 this.historyEmptyMessage = document.querySelector('.history-empty-message');

                // Effects UI
                 this.eqSliders = {
                     low: document.getElementById('eq-low'),
                     mid: document.getElementById('eq-mid'),
                     high: document.getElementById('eq-high')
                 };
                 this.eqValueDisplays = {
                     low: document.getElementById('eq-low-val'),
                     mid: document.getElementById('eq-mid-val'),
                     high: document.getElementById('eq-high-val')
                 };
                 this.reverbToggle = document.getElementById('reverb-toggle');

                // Modals
                this.themesBtn = document.getElementById('themes-btn');
                this.profileBtn = document.getElementById('profile-btn');
                this.themesModal = document.getElementById('themes-modal');
                this.profileModal = document.getElementById('profile-modal');
                this.themeOptions = document.querySelectorAll('.theme-option');
                this.saveProfileBtn = document.getElementById('save-profile-btn');
                this.modals = document.querySelectorAll('.modal');
                this.modalTriggers = {};
            }

            initEventListeners() {
                // Playback Controls
                this.playPauseBtn.addEventListener('click', () => this.togglePlay());
                this.prevBtn.addEventListener('click', () => this.playPrevious());
                this.nextBtn.addEventListener('click', () => this.playNext());
                this.volumeSlider.addEventListener('input', () => {
                    this.setVolume();
                    this.saveStateToLocalStorage(); // Save volume change
                });
                this.progressContainer.addEventListener('click', (e) => this.setProgress(e));

                // Audio Element Events
                this.audioElement.addEventListener('timeupdate', () => this.updateProgress());
                this.audioElement.addEventListener('loadedmetadata', () => this.updateDuration());
                this.audioElement.addEventListener('ended', () => this.playNext());
                this.audioElement.addEventListener('error', (e) => this.handleAudioError(e));
                 this.audioElement.addEventListener('pause', () => { if (this.isPlaying) this.pauseSongVisuals(); }); // Handle pause from sources other than button
                 this.audioElement.addEventListener('play', () => { if (!this.isPlaying) this.playSongVisuals(); }); // Handle play from sources other than button

                 // File Handling
                 this.addSongTriggerBtn.addEventListener('click', () => this.hiddenFileInput.click());
                 this.hiddenFileInput.addEventListener('change', (e) => this.handleFilesSelected(e.target.files));

                // Effects Controls
                Object.keys(this.eqSliders).forEach(band => {
                    this.eqSliders[band].addEventListener('input', (e) => this.setEQ(band, e.target.value));
                });
                this.reverbToggle.addEventListener('change', (e) => this.toggleReverb(e.target.checked));

                 // Minimal Mode
                 this.minimalToggleBtn.addEventListener('click', () => this.toggleMinimalMode());

                // Modal controls (Themes, Profile) - Unchanged from previous version
                this.themesBtn.addEventListener('click', (e) => this.toggleModal(this.themesModal, e.currentTarget));
                this.profileBtn.addEventListener('click', (e) => this.toggleModal(this.profileModal, e.currentTarget));
                this.themeOptions.forEach(option => {
                    option.addEventListener('click', () => {
                        const theme = option.dataset.theme;
                        this.applyTheme(theme);
                         this.saveStateToLocalStorage(); // Save selected theme
                        this.closeModal(this.themesModal);
                    });
                });
                 this.saveProfileBtn.addEventListener('click', () => this.saveProfileSettings());
                this.modals.forEach(modal => {
                    modal.addEventListener('click', (e) => {
                         if (e.target === modal || e.target.closest('.modal-close-btn')) {
                             this.closeModal(modal);
                         }
                    });
                    modal.addEventListener('keydown', (e) => { if (e.key === 'Escape') this.closeModal(modal); });
                });
            }

            initGSAPAnimations() {
                // Initial page load animations (slightly adjusted delays)
                gsap.from(this.vinylPlayer, { duration: 1, scale: 0.8, rotation: -30, opacity: 0, ease: "back.out(1.7)", delay: 0.3 });
                gsap.from(this.vinylArm, { duration: 1, rotation: -60, opacity: 0, ease: "power2.out", delay: 0.6 });
                gsap.from(this.visualizerContainer, { duration: 0.8, y: 30, opacity: 0, delay: 0.8, ease: "power2.out" });
                gsap.from(this.progressContainer, { duration: 0.8, y: 30, opacity: 0, delay: 0.9, ease: "power2.out" });
            }

            // --- AUDIO CONTEXT & NODE SETUP ---

             async initAudioContextIfNeeded() {
                if (this.audioContext) return true; // Already initialized

                 // Check if context is suspended and needs resuming (common browser policy)
                 if (this.audioContext && this.audioContext.state === 'suspended') {
                     try {
                         await this.audioContext.resume();
                         console.log("AudioContext resumed.");
                         return true;
                     } catch (err) {
                         console.error("Failed to resume AudioContext:", err);
                         this.showRetroAlert("Could not start audio. Please interact with the page again.");
                         return false;
                     }
                 }

                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.gainNode = this.audioContext.createGain(); // Master gain
                    this.analyserNode = this.audioContext.createAnalyser();
                    this.analyserNode.fftSize = 256; // Adjust for visualizer detail vs performance
                     this.visualizerDataArray = new Uint8Array(this.analyserNode.frequencyBinCount);

                    // Create EQ Nodes
                    this.eqNodes.low = this.audioContext.createBiquadFilter();
                    this.eqNodes.mid = this.audioContext.createBiquadFilter();
                    this.eqNodes.high = this.audioContext.createBiquadFilter();

                    // Configure EQ Nodes (example frequencies)
                    this.eqNodes.low.type = 'lowshelf';
                    this.eqNodes.low.frequency.setValueAtTime(250, this.audioContext.currentTime); // Below 250 Hz
                    this.eqNodes.mid.type = 'peaking';
                    this.eqNodes.mid.frequency.setValueAtTime(1000, this.audioContext.currentTime); // Around 1 kHz
                    this.eqNodes.mid.Q.setValueAtTime(1, this.audioContext.currentTime); // Bandwidth
                    this.eqNodes.high.type = 'highshelf';
                    this.eqNodes.high.frequency.setValueAtTime(4000, this.audioContext.currentTime); // Above 4 kHz

                    // Create Reverb Nodes
                    this.reverbNode = this.audioContext.createConvolver();
                    this.reverbGain = this.audioContext.createGain();
                    this.reverbGain.gain.setValueAtTime(0, this.audioContext.currentTime); // Reverb off by default

                    // Load Reverb Impulse Response
                    await this.loadImpulseResponse('/path/to/your/impulse-response.wav'); // !!! REPLACE WITH ACTUAL PATH !!!

                    // Connect Audio Element Source (if not already connected)
                     if (!this.sourceNode) {
                         this.sourceNode = this.audioContext.createMediaElementSource(this.audioElement);
                     }

                    // Connect Nodes: source -> EQ -> Gain (Master) -> Analyser -> Destination
                    //               `-> ReverbGain -> ReverbNode ->`
                    this.sourceNode.connect(this.eqNodes.low);
                    this.eqNodes.low.connect(this.eqNodes.mid);
                    this.eqNodes.mid.connect(this.eqNodes.high);
                    this.eqNodes.high.connect(this.gainNode); // Main signal path to master gain

                    // Reverb path (parallel)
                    this.eqNodes.high.connect(this.reverbGain); // Send signal to reverb gain control
                    this.reverbGain.connect(this.reverbNode); // Reverb gain to convolver
                    this.reverbNode.connect(this.gainNode); // Convolver output back to master gain

                    // Master gain to analyser and destination
                    this.gainNode.connect(this.analyserNode);
                    this.analyserNode.connect(this.audioContext.destination);

                     // Apply loaded EQ/Reverb settings
                     this.applyLoadedEffectsSettings();

                    console.log("AudioContext and Nodes initialized.");
                    return true;
                } catch (e) {
                    console.error("Error initializing Web Audio API:", e);
                    this.showRetroAlert("Web Audio API not supported or failed to initialize.");
                    return false;
                }
            }

             async loadImpulseResponse(url) {
                 try {
                     const response = await fetch(url);
                     if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                     const arrayBuffer = await response.arrayBuffer();
                     this.reverbBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                     this.reverbNode.buffer = this.reverbBuffer;
                     console.log("Impulse response loaded successfully.");
                 } catch (error) {
                     console.error("Failed to load impulse response:", error);
                     this.showRetroAlert("Could not load reverb effect.");
                     // Disable reverb UI if loading fails?
                     this.reverbToggle.disabled = true;
                     this.reverbToggle.checked = false;
                     this.isReverbEnabled = false;
                 }
             }


            // --- PLAYBACK ---

            async togglePlay() {
                if (this.songs.length === 0) {
                     this.showRetroAlert("No songs in the playlist!");
                     return;
                 }

                 // Initialize AudioContext on first play attempt
                 if (!await this.initAudioContextIfNeeded()) return;

                if (this.isPlaying) {
                    this.pauseSong();
                } else {
                    if (this.currentSongIndex === -1) {
                        this.currentSongIndex = 0;
                    }
                    // Ensure song data (blobUrl) is available before playing
                    if (this.songs[this.currentSongIndex] && this.songs[this.currentSongIndex].blobUrl) {
                        this.loadSong(this.songs[this.currentSongIndex], true); // Load and play
                    } else {
                         // This happens after page reload - need user to interact with the song item
                         this.showRetroAlert("Please click on a song in the list to load it first after a reload.");
                         // Optionally try to re-acquire file handle if available (more complex)
                    }
                }
            }

            playSong() {
                if (!this.audioElement || !this.songs[this.currentSongIndex] || !this.songs[this.currentSongIndex].blobUrl) {
                     console.warn("Cannot play: Audio element or song data missing.");
                     this.showRetroAlert("Cannot play song. Please select a valid track.");
                     return;
                 }
                 if (!this.audioContext || this.audioContext.state !== 'running') {
                     console.warn("AudioContext not running. Attempting resume...");
                     this.initAudioContextIfNeeded().then(success => {
                         if (success) this.audioElement.play().catch(e => this.handleAudioError(e));
                     });
                 } else {
                     this.audioElement.play().catch(e => this.handleAudioError(e));
                 }

                this.playSongVisuals(); // Update UI immediately
            }

             playSongVisuals() {
                 if (this.isPlaying) return; // Already playing visually

                 this.isPlaying = true;
                 this.playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                 this.playPauseBtn.setAttribute('aria-label', 'Pause');
                 this.vinylPlayer.classList.add('spinning');
                 this.vinylArm.classList.add('playing');
                 this.startVisualizer();
                 this.playSoundEffect(this.stylusSound); // Stylus drop sound
                 this.updateActiveSongInHistory();
                 gsap.to(this.playPauseBtn, { scale: 1.1, duration: 0.1, yoyo: true, repeat: 1 });
             }

            pauseSong() {
                this.audioElement.pause();
                this.pauseSongVisuals();
            }

             pauseSongVisuals() {
                 if (!this.isPlaying) return; // Already paused visually

                 this.isPlaying = false;
                 this.playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                 this.playPauseBtn.setAttribute('aria-label', 'Play');
                 this.vinylPlayer.classList.remove('spinning');
                 this.vinylArm.classList.remove('playing');
                 this.stopVisualizer();
                 // Don't play stylus lift sound on every pause, maybe only on song change?
                 gsap.to(this.playPauseBtn, { scale: 1.0, duration: 0.1 });
             }

            loadSong(songData, playImmediately = false) {
                 if (!songData || !songData.blobUrl) {
                    console.error("Load failed: Missing song data or blobUrl", songData);
                     this.showRetroAlert("Cannot load this song. It might need re-uploading.");
                    return;
                 }

                this.pauseSongVisuals(); // Stop visuals of previous song
                // Play stylus lift sound? (Maybe too much)

                 // Update UI
                 this.songTitle.textContent = songData.title;
                 this.songArtist.textContent = songData.artist || "Unknown Artist";
                 this.currentTimeEl.textContent = "0:00";
                 this.durationEl.textContent = "--:--";
                 this.progressBar.style.width = "0%";

                 try {
                     this.audioElement.src = songData.blobUrl;
                     this.audioElement.load(); // Important
                     this.setVolume(); // Apply current volume setting

                     console.log("Loading song:", songData.title);
                     this.updateActiveSongInHistory();
                     this.saveStateToLocalStorage(); // Save new current index

                     if (playImmediately) {
                         // Use 'canplay' event as a trigger
                         const canPlayHandler = () => {
                             this.playSong();
                             this.audioElement.removeEventListener('canplay', canPlayHandler); // Clean up listener
                         };
                         this.audioElement.addEventListener('canplay', canPlayHandler);
                         // Fallback timeout in case 'canplay' doesn't fire reliably
                         setTimeout(() => {
                              if (!this.isPlaying && playImmediately && this.currentSongIndex === this.songs.indexOf(songData)) {
                                 this.playSong();
                                 this.audioElement.removeEventListener('canplay', canPlayHandler); // Clean up listener
                              }
                          }, 1500);
                     }
                 } catch (error) {
                     console.error("Error setting audio source:", error);
                     this.showRetroAlert(`Failed to load ${songData.title}.`);
                     this.resetPlayer();
                 }
            }

            playNext() {
                if (this.songs.length === 0) return;
                this.playSoundEffect(this.scratchSound); // Scratch sound
                const wasPlaying = this.isPlaying;
                this.currentSongIndex = (this.currentSongIndex + 1) % this.songs.length;
                 if (this.songs[this.currentSongIndex].blobUrl) {
                    this.loadSong(this.songs[this.currentSongIndex], wasPlaying);
                 } else {
                     this.pauseSongVisuals(); // Stop visuals if next song isn't ready
                     this.showRetroAlert(`'${this.songs[this.currentSongIndex].title}' needs to be loaded. Click it in the list.`);
                     this.updateUIForUnloadedSong(this.songs[this.currentSongIndex]);
                 }
            }

            playPrevious() {
                if (this.songs.length === 0) return;
                 this.playSoundEffect(this.scratchSound); // Scratch sound
                const wasPlaying = this.isPlaying;
                this.currentSongIndex = (this.currentSongIndex - 1 + this.songs.length) % this.songs.length;
                 if (this.songs[this.currentSongIndex].blobUrl) {
                    this.loadSong(this.songs[this.currentSongIndex], wasPlaying);
                 } else {
                      this.pauseSongVisuals();
                     this.showRetroAlert(`'${this.songs[this.currentSongIndex].title}' needs to be loaded. Click it in the list.`);
                      this.updateUIForUnloadedSong(this.songs[this.currentSongIndex]);
                 }
            }

             updateUIForUnloadedSong(songData) {
                 // Update title/artist but show 0 duration and don't play
                 this.songTitle.textContent = songData.title;
                 this.songArtist.textContent = songData.artist || "Unknown Artist";
                 this.currentTimeEl.textContent = "0:00";
                 this.durationEl.textContent = "0:00";
                 this.progressBar.style.width = "0%";
                 this.updateActiveSongInHistory();
                 this.saveStateToLocalStorage(); // Save new index
             }


            setVolume() {
                const volumeValue = this.volumeSlider.value;
                 this.audioElement.volume = volumeValue;
                 // Also adjust master gain in AudioContext if initialized
                 if (this.gainNode) {
                     // Use a logarithmic scale for perceived loudness (optional but better)
                     // Example: Convert linear 0-1 to dB range -60 to 0
                     // const dB = volumeValue > 0 ? 20 * Math.log10(volumeValue) : -Infinity;
                     // this.gainNode.gain.setTargetAtTime(volumeValue, this.audioContext.currentTime, 0.01);
                     // Simple linear mapping for now:
                     this.gainNode.gain.setValueAtTime(volumeValue, this.audioContext.currentTime);
                 }
            }

            updateDuration() {
                if (this.audioElement && !isNaN(this.audioElement.duration)) {
                     const formattedTime = this.formatTime(this.audioElement.duration);
                     this.durationEl.textContent = formattedTime;
                     // Update duration in the history list item if it's the current song
                     const activeItem = this.historyList.querySelector('.history-item.active .history-item-duration');
                     if (activeItem) {
                         activeItem.textContent = formattedTime;
                     }
                     // Update the duration in our main songs array (if needed, though formatTime is dynamic)
                     if(this.songs[this.currentSongIndex]) {
                         this.songs[this.currentSongIndex].duration = formattedTime;
                         // No need to save to localStorage just for duration update
                     }
                } else {
                    this.durationEl.textContent = "--:--";
                }
             }

            updateProgress() {
                 if (!this.audioElement || !this.isPlaying || isNaN(this.audioElement.duration) || this.audioElement.duration <= 0) return;
                 const { currentTime, duration } = this.audioElement;
                 const progressPercent = (currentTime / duration) * 100;
                 this.progressBar.style.width = `${progressPercent}%`;
                 this.currentTimeEl.textContent = this.formatTime(currentTime);
            }

            setProgress(e) {
                if (!this.audioElement || isNaN(this.audioElement.duration) || this.audioElement.duration <= 0) return;
                 if (!this.songs[this.currentSongIndex]?.blobUrl) {
                     this.showRetroAlert("Load the song first by clicking it in the list.");
                     return; // Don't allow seeking on unloaded songs
                 }
                const width = this.progressContainer.clientWidth;
                const clickX = e.offsetX;
                const duration = this.audioElement.duration;
                const newTime = (clickX / width) * duration;
                this.audioElement.currentTime = Math.min(newTime, duration - 0.1);
                this.updateProgress(); // Update UI immediately
            }

            formatTime(seconds) { /* Unchanged */ seconds = isNaN(seconds) || seconds < 0 ? 0 : seconds; const minutes = Math.floor(seconds / 60); const secs = Math.floor(seconds % 60); return `${minutes}:${secs < 10 ? '0' : ''}${secs}`; }

            handleAudioError(e) {
                console.error("Audio Error:", e, this.audioElement.error);
                 const songTitle = this.songs[this.currentSongIndex]?.title || 'the current track';
                 let message = `Error playing ${songTitle}.`;
                 if (this.audioElement.error) {
                     switch (this.audioElement.error.code) {
                         case MediaError.MEDIA_ERR_ABORTED: message += ' Playback aborted.'; break;
                         case MediaError.MEDIA_ERR_NETWORK: message += ' Network error.'; break;
                         case MediaError.MEDIA_ERR_DECODE: message += ' Decoding error (file might be corrupt or unsupported format).'; break;
                         case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED: message += ' Format not supported.'; break;
                         default: message += ' Unknown error.';
                     }
                 }
                this.showRetroAlert(message);
                this.resetPlayer();
            }

             playSoundEffect(sound) {
                 if (sound && this.audioContext) { // Only play if context is active
                     sound.currentTime = 0;
                     sound.play().catch(e => console.warn("Sound effect playback failed:", e));
                 }
             }

            // --- FILE HANDLING & PLAYLIST ---

             handleFilesSelected(files) {
                 if (!files || files.length === 0) return;

                 this.addSongTriggerBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Adding...';
                 this.addSongTriggerBtn.disabled = true;

                 const addedSongs = [];
                 let processedCount = 0;

                 Array.from(files).forEach(file => {
                     if (!file.type.startsWith('audio/')) {
                         console.warn(`Skipping non-audio file: ${file.name}`);
                         processedCount++;
                         if (processedCount === files.length) this.finishAddingSongs(addedSongs);
                         return;
                     }

                     const reader = new FileReader();

                     reader.onload = (e) => {
                         // Basic metadata from filename
                         const title = file.name.replace(/\.[^/.]+$/, ""); // Remove extension
                         const artist = "Unknown Artist"; // Placeholder - jsmediatags could improve this
                         const blobUrl = URL.createObjectURL(file);

                         const newSong = {
                             title: title,
                             artist: artist,
                             duration: "--:--", // Will be updated on load
                             blobUrl: blobUrl,
                             fileName: file.name // Store filename for potential re-matching later?
                         };

                         this.songs.push(newSong);
                         addedSongs.push(newSong);
                         this.addSongToHistory(newSong, true); // Add to UI

                         processedCount++;
                         if (processedCount === files.length) this.finishAddingSongs(addedSongs);
                     };

                     reader.onerror = (e) => {
                         console.error(`Error reading file ${file.name}:`, e);
                         this.showRetroAlert(`Error reading file ${file.name}.`);
                         processedCount++;
                         if (processedCount === files.length) this.finishAddingSongs(addedSongs);
                     };

                     reader.readAsArrayBuffer(file); // Needed for jsmediatags or just to trigger onload
                 });
             }

            finishAddingSongs(addedSongs) {
                 this.addSongTriggerBtn.innerHTML = '<i class="fas fa-plus"></i> Add Audio Files';
                 this.addSongTriggerBtn.disabled = false;
                 this.hiddenFileInput.value = ''; // Clear file input

                 if (addedSongs.length > 0) {
                     this.showRetroAlert(`Added ${addedSongs.length} song(s). Remember to re-upload after reloading the page.`);
                     this.saveStateToLocalStorage(); // Save updated playlist metadata
                     this.updateEmptyMessage();

                     // If player was empty, select the first added song (but don't auto-play)
                     if (this.currentSongIndex === -1 && this.songs.length > 0) {
                         this.currentSongIndex = this.songs.indexOf(addedSongs[0]);
                         this.updateUIForUnloadedSong(this.songs[this.currentSongIndex]); // Show info but don't load yet
                     }
                 }
            }


            addSongToHistory(songData, animate = false) {
                 const li = document.createElement('li');
                 li.className = 'history-item';
                 const songIndex = this.songs.indexOf(songData);
                 li.dataset.index = songIndex;

                 li.innerHTML = `
                    <div class="history-item-info">
                        <div class="history-item-title">${songData.title}</div>
                        <div class="history-item-artist">${songData.artist}</div>
                    </div>
                    <span class="history-item-duration">${songData.duration || '--:--'}</span>
                    <button type="button" class="remove-btn" aria-label="Remove ${songData.title}"><i class="fas fa-times"></i></button>
                `;

                 li.addEventListener('click', async (e) => {
                     if (e.target.closest('.remove-btn')) return;
                     const index = parseInt(li.dataset.index, 10);

                     if (index === this.currentSongIndex && this.isPlaying) return; // Ignore click on playing item

                      if (!await this.initAudioContextIfNeeded()) return; // Ensure context ready

                     if (index >= 0 && index < this.songs.length) {
                         this.currentSongIndex = index;
                         // Check if blobUrl exists (it should if just added, might not after reload)
                         if (this.songs[index].blobUrl) {
                             this.loadSong(this.songs[index], true); // Load and play
                         } else {
                             // This is the case after reload - NEED to re-acquire the file
                             this.showRetroAlert(`'${this.songs[index].title}' needs to be loaded. Please re-select the file.`);
                             // Try to trigger file input specifically for this song? (Complex)
                             // For now, just update UI and wait for re-upload
                              this.updateUIForUnloadedSong(this.songs[index]);
                         }
                     }
                 });

                 const removeBtn = li.querySelector('.remove-btn');
                 removeBtn.addEventListener('click', (e) => {
                     e.stopPropagation();
                     this.removeSongFromHistory(li);
                 });

                 this.historyList.appendChild(li);
                 this.updateEmptyMessage();

                 if (animate) {
                     gsap.from(li, { duration: 0.4, y: 20, opacity: 0, ease: "power2.out" });
                 }
             }

             removeSongFromHistory(listItem) {
                 const indexToRemove = parseInt(listItem.dataset.index, 10);
                 if (isNaN(indexToRemove) || indexToRemove < 0 || indexToRemove >= this.songs.length) return;

                 const removedSongData = this.songs[indexToRemove];

                 gsap.to(listItem, {
                     duration: 0.3, x: 50, opacity: 0, ease: "power1.in",
                     onComplete: () => {
                         if (listItem.parentNode === this.historyList) {
                             listItem.remove();
                         }
                         // Clean up Blob URL to free memory
                         if (removedSongData && removedSongData.blobUrl) {
                             URL.revokeObjectURL(removedSongData.blobUrl);
                         }

                         this.songs.splice(indexToRemove, 1);

                         // Update indices of remaining items
                         this.historyList.querySelectorAll('.history-item').forEach((item, idx) => {
                             item.dataset.index = idx;
                         });

                         // Adjust player state
                         if (this.songs.length === 0) {
                             this.resetPlayer();
                         } else if (this.currentSongIndex === indexToRemove) {
                             // Removed song was active
                              this.pauseSongVisuals();
                             this.currentSongIndex = Math.min(indexToRemove, this.songs.length - 1);
                              if (this.currentSongIndex >= 0) {
                                  // Select new song but don't load/play automatically
                                   this.updateUIForUnloadedSong(this.songs[this.currentSongIndex]);
                              } else {
                                  this.resetPlayer();
                              }
                         } else if (this.currentSongIndex > indexToRemove) {
                             this.currentSongIndex--;
                             this.updateActiveSongInHistory(); // Update highlight
                         }

                         this.saveStateToLocalStorage(); // Save changes
                         this.updateEmptyMessage();
                     }
                 });
             }

            updateActiveSongInHistory() {
                 this.historyList.querySelectorAll('.history-item').forEach(item => {
                     const index = parseInt(item.dataset.index, 10);
                     if (index === this.currentSongIndex) {
                         item.classList.add('active');
                         // Scroll into view if needed
                          item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                     } else {
                         item.classList.remove('active');
                     }
                 });
             }

             updateEmptyMessage() {
                 if (this.songs.length === 0) {
                     this.historyEmptyMessage.style.display = 'block';
                 } else {
                     this.historyEmptyMessage.style.display = 'none';
                 }
             }


            resetPlayer() {
                 this.pauseSongVisuals();
                 if(this.audioElement) { this.audioElement.src = ''; }
                 this.currentSongIndex = -1;
                 this.songTitle.textContent = "No song selected";
                 this.songArtist.textContent = "Upload audio files";
                 this.progressBar.style.width = "0%";
                 this.currentTimeEl.textContent = "0:00";
                 this.durationEl.textContent = "0:00";
                 this.updateActiveSongInHistory();
                 this.stopVisualizer();
                 // Don't clear this.songs here, maybe user wants to re-upload
            }


            // --- EFFECTS ---

            setEQ(band, value) {
                 if (!this.audioContext || !this.eqNodes[band]) return;
                 const gainValue = parseFloat(value);
                 this.eqNodes[band].gain.setTargetAtTime(gainValue, this.audioContext.currentTime, 0.05); // Smooth transition
                 // Update UI display
                 this.eqValueDisplays[band].textContent = `${gainValue} dB`;
                 // Save EQ settings
                 this.saveStateToLocalStorage();
             }

             toggleReverb(enabled) {
                 if (!this.audioContext || !this.reverbGain || !this.reverbBuffer) return;
                 this.isReverbEnabled = enabled;
                 const targetGain = enabled ? 0.7 : 0; // Adjust reverb mix level (0.7 is an example)
                 this.reverbGain.gain.setTargetAtTime(targetGain, this.audioContext.currentTime, 0.1); // Smooth transition
                 console.log(`Reverb ${enabled ? 'enabled' : 'disabled'}`);
                 // Save Reverb state
                 this.saveStateToLocalStorage();
             }

            applyLoadedEffectsSettings() {
                 const settings = JSON.parse(localStorage.getItem('vinylPlayerEffects')) || {};
                 Object.keys(this.eqSliders).forEach(band => {
                     const value = settings.eq?.[band] !== undefined ? settings.eq[band] : 0;
                     this.eqSliders[band].value = value;
                     this.setEQ(band, value); // Apply the value through the setter
                 });
                 const reverbEnabled = settings.reverbEnabled !== undefined ? settings.reverbEnabled : false;
                 this.reverbToggle.checked = reverbEnabled;
                 this.toggleReverb(reverbEnabled); // Apply through the toggler
             }


            // --- VISUALIZER ---

            startVisualizer() {
                if (!this.audioContext || !this.analyserNode || this.animationFrameId) return; // Don't start if no context or already running
                 console.log("Starting visualizer...");
                const draw = () => {
                    if (!this.isPlaying) { // Stop if paused externally
                         this.stopVisualizer();
                         return;
                     }
                    this.animationFrameId = requestAnimationFrame(draw);

                    this.analyserNode.getByteFrequencyData(this.visualizerDataArray);

                    this.canvasCtx.fillStyle = getComputedStyle(this.visualizerContainer).backgroundColor || 'rgba(0,0,0,0.2)'; // Match theme background
                    this.canvasCtx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    const barWidth = (this.canvas.width / this.analyserNode.frequencyBinCount) * 1.5; // Wider bars
                    let x = 0;
                     const accentColor = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();

                    for (let i = 0; i < this.analyserNode.frequencyBinCount; i++) {
                        const barHeight = (this.visualizerDataArray[i] / 255) * this.canvas.height * 0.8; // Scale height

                        // Simple gradient or use theme accent
                        this.canvasCtx.fillStyle = accentColor || 'rgb(230, 57, 70)';
                         // Optional gradient:
                         // const gradient = this.canvasCtx.createLinearGradient(0, this.canvas.height, 0, this.canvas.height - barHeight);
                         // gradient.addColorStop(0, accentColor);
                         // gradient.addColorStop(1, colorMix(accentColor, '#ffffff', 0.5)); // Lighter top
                         // this.canvasCtx.fillStyle = gradient;

                        this.canvasCtx.fillRect(x, this.canvas.height - barHeight, barWidth, barHeight);
                        x += barWidth + 1; // Add 1 for spacing
                    }
                };
                draw();
            }

            stopVisualizer() {
                 if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                    // Optionally clear canvas
                     setTimeout(() => { // Clear after a short delay
                         if(!this.isPlaying) this.canvasCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                     }, 100);
                    console.log("Visualizer stopped.");
                 }
            }


            // --- MINIMAL MODE ---

             toggleMinimalMode() {
                 this.isMinimalMode = !this.isMinimalMode;
                 const duration = 0.5;
                 const ease = "power2.inOut";

                 // Update button icon
                  this.minimalToggleBtn.innerHTML = this.isMinimalMode ? '<i class="fas fa-expand-alt"></i>' : '<i class="fas fa-compress-alt"></i>';
                  this.minimalToggleBtn.setAttribute('aria-label', this.isMinimalMode ? 'Exit Minimal Mode' : 'Enter Minimal Mode');


                 const tl = gsap.timeline({
                     onComplete: () => {
                         // Recalculate canvas size if needed after transition
                         // this.canvas.width = this.visualizerContainer.offsetWidth;
                         // this.canvas.height = this.visualizerContainer.offsetHeight;
                     }
                 });

                 if (this.isMinimalMode) {
                     this.appContainer.classList.add('minimal-mode');
                     tl.to(".controls-section, .song-history-section", { duration: duration, opacity: 0, x: (el) => el.classList.contains('controls-section') ? -50 : 50, ease: ease }, 0)
                       .to(".bottom-nav", { duration: duration, opacity: 0, y: 30, ease: ease }, 0)
                       .to(this.vinylSection, { duration: duration, scale: 0.9, y: '-10%', ease: ease }, 0) // Move vinyl up slightly
                       .to(this.progressContainer, { duration: duration, y: '50px', ease: ease }, 0); // Move progress bar relative to its new center

                 } else {
                     // Reverse animation
                     tl.to(this.progressContainer, { duration: duration, y: '0px', ease: ease }, 0)
                       .to(this.vinylSection, { duration: duration, scale: 1, y: '0%', ease: ease }, 0)
                       .to(".controls-section, .song-history-section", { duration: duration, opacity: 1, x: 0, ease: ease, onComplete: () => this.appContainer.classList.remove('minimal-mode') }, 0) // Remove class at end
                       .to(".bottom-nav", { duration: duration, opacity: 1, y: 0, ease: ease }, 0);
                 }
             }


            // --- LOCAL STORAGE ---

            saveStateToLocalStorage() {
                try {
                    // Playlist: Save only metadata (title, artist, filename) - blobUrls are temporary!
                    const playlistMetadata = this.songs.map(song => ({
                        title: song.title,
                        artist: song.artist,
                        duration: song.duration,
                        fileName: song.fileName // Store filename
                    }));
                    localStorage.setItem('vinylPlayerPlaylist', JSON.stringify(playlistMetadata));

                    localStorage.setItem('vinylPlayerIndex', this.currentSongIndex.toString());
                    localStorage.setItem('vinylPlayerVolume', this.volumeSlider.value);
                    localStorage.setItem('vinylPlayerTheme', document.body.className.split(' ').find(cls => cls.startsWith('theme-')) || 'theme-mkbhd');

                    // Save Effects Settings
                     const effectsSettings = {
                         eq: {
                             low: this.eqSliders.low.value,
                             mid: this.eqSliders.mid.value,
                             high: this.eqSliders.high.value
                         },
                         reverbEnabled: this.isReverbEnabled
                     };
                     localStorage.setItem('vinylPlayerEffects', JSON.stringify(effectsSettings));

                    // console.log("State saved to localStorage");
                } catch (e) {
                    console.error("Error saving state to localStorage:", e);
                     // Handle potential quota exceeded error
                     if (e.name === 'QuotaExceededError') {
                         this.showRetroAlert("Storage full! Cannot save playlist changes.");
                     }
                }
            }

            loadStateFromLocalStorage() {
                try {
                     // Load Playlist Metadata
                     const savedPlaylist = JSON.parse(localStorage.getItem('vinylPlayerPlaylist') || '[]');
                     // IMPORTANT: Create song objects but mark blobUrl as null initially
                     this.songs = savedPlaylist.map(meta => ({ ...meta, blobUrl: null }));

                     // Load Index
                    const savedIndex = parseInt(localStorage.getItem('vinylPlayerIndex') || '-1', 10);
                    this.currentSongIndex = (savedIndex >= 0 && savedIndex < this.songs.length) ? savedIndex : -1;

                    // Load Volume
                    const savedVolume = parseFloat(localStorage.getItem('vinylPlayerVolume') || '0.7');
                    this.volumeSlider.value = savedVolume;
                     this.setVolume(); // Apply loaded volume

                     // Load Theme is handled by applying it after init

                     // Load Effects settings (will be applied when context initializes)

                    // Populate History List UI from loaded metadata
                    this.historyList.innerHTML = ''; // Clear any defaults
                    this.songs.forEach(song => this.addSongToHistory(song, false)); // Add without animation

                    // Update UI for the potentially loaded song (but don't try to load blobUrl)
                    if (this.currentSongIndex !== -1) {
                         this.updateUIForUnloadedSong(this.songs[this.currentSongIndex]);
                    } else if(this.songs.length === 0) {
                         this.resetPlayer();
                    }

                     console.log("State loaded from localStorage");
                     if (this.songs.length > 0) {
                         this.showRetroAlert("Playlist loaded. Click a song to load the file.", 4000);
                     }

                } catch (e) {
                    console.error("Error loading state from localStorage:", e);
                    this.songs = []; // Reset state if loading fails
                    this.currentSongIndex = -1;
                }
            }

            // --- THEME & PROFILE ---

             applyTheme(theme) {
                 document.body.className = `theme-${theme}`;
                 this.updateAccentColorFromTheme(theme); // Update profile color picker
                 // Force canvas redraw with new theme colors if visualizer is active
                 if (this.isPlaying && this.animationFrameId) {
                     // Could redraw immediately or just let the next frame handle it
                 }
             }


            updateAccentColorFromTheme(themeName) { /* Unchanged */ const themeElement = document.querySelector(`.theme-option.${themeName}`); if (!themeElement) return; const tempDiv = document.createElement('div'); document.body.appendChild(tempDiv); tempDiv.className = `theme-${themeName}`; const accentColor = getComputedStyle(tempDiv).getPropertyValue('--accent').trim(); document.body.removeChild(tempDiv); const colorInput = document.getElementById('color-input'); if (colorInput && accentColor) { colorInput.value = this.rgbToHex(accentColor) || accentColor; } this.appContainer.style.setProperty('--accent', accentColor); }
            // Helper to convert potential rgb() from getComputedStyle to hex for color input
            rgbToHex(rgb) { if (!rgb || !rgb.startsWith('rgb')) return rgb; const result = /^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/.exec(rgb); if(!result) return rgb; return "#" + ((1 << 24) + (parseInt(result[1]) << 16) + (parseInt(result[2]) << 8) + parseInt(result[3])).toString(16).slice(1).toUpperCase(); }

            saveProfileSettings() { /* Unchanged */ const username = document.getElementById('username-input').value; const genre = document.getElementById('genre-select').value; const color = document.getElementById('color-input').value; console.log("Profile Settings Saved (Placeholder):", { username, genre, color }); this.showRetroAlert("Profile settings saved (placeholder)."); this.appContainer.style.setProperty('--accent', color); this.closeModal(this.profileModal); /* Save to localStorage? */ }

            // --- MODAL CONTROLS --- (Unchanged from previous version)
             toggleModal(modal, triggerElement = null) { if (modal.classList.contains('active')) { this.closeModal(modal); } else { this.openModal(modal, triggerElement); } }
             openModal(modal, triggerElement = null) { this.modals.forEach(m => { if (m !== modal) this.closeModal(m); }); modal.classList.add('active'); if (triggerElement) { this.modalTriggers[modal.id] = triggerElement; } const focusable = modal.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'); if (focusable) { setTimeout(() => focusable.focus(), 50); } document.body.style.overflow = 'hidden'; }
             closeModal(modal) { modal.classList.remove('active'); const trigger = this.modalTriggers[modal.id]; if (trigger) { setTimeout(() => trigger.focus(), 50); delete this.modalTriggers[modal.id]; } const anyModalActive = Array.from(this.modals).some(m => m.classList.contains('active')); if (!anyModalActive) { document.body.style.overflow = ''; } }

            // --- RETRO ALERT --- (Slightly improved show/hide logic)
            showRetroAlert(message, duration = 3500) {
                const existingAlert = this.alertContainer.querySelector('.retro-alert');
                if(existingAlert) {
                    // If message is the same, just reset timer
                    if (existingAlert.textContent === message && this.alertTimeout) {
                         clearTimeout(this.alertTimeout);
                    } else {
                         // Remove old alert immediately if message is different
                         gsap.killTweensOf(existingAlert); // Stop any running animations
                         existingAlert.remove();
                         if (this.alertTimeout) clearTimeout(this.alertTimeout);
                    }
                }

                const alertDiv = document.createElement('div');
                alertDiv.className = 'retro-alert';
                alertDiv.textContent = message;
                this.alertContainer.appendChild(alertDiv);

                gsap.to(alertDiv, {
                    top: '10px', opacity: 1, duration: 0.4, ease: 'back.out(1.7)',
                    onComplete: () => {
                        this.alertTimeout = setTimeout(() => { this.hideRetroAlert(alertDiv); }, duration);
                    }
                });
             }

             hideRetroAlert(alertDiv) {
                 if (!alertDiv || alertDiv.parentNode !== this.alertContainer) return; // Already removed
                 gsap.to(alertDiv, {
                     top: '-150px', opacity: 0, duration: 0.4, ease: 'power1.in',
                     onComplete: () => {
                         if (alertDiv.parentNode === this.alertContainer) alertDiv.remove();
                         if (this.alertTimeout) clearTimeout(this.alertTimeout);
                         this.alertTimeout = null;
                     }
                 });
             }
        }

        // --- Initialize ---
        document.addEventListener('DOMContentLoaded', () => {
            window.musicPlayer = new MusicPlayer(); // Make accessible globally for debug
        });

    </script>

</body>
</html>

